# -*- coding: utf-8 -*-
"""3-sizes_3_methods_set_generation_script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_OcwpcycOy2BZQM4IH4VpGIKqQ8mJ5SU
"""



import time
import json
import random
import re
from collections import Counter, defaultdict
from pathlib import Path



def parse_solution(filepath):
    pattern = r'Pairing\s+(\d+)\s*:\s*Base\s+(\w+)\s*:\s*([^;]+);'
    with open(filepath, 'r') as f:
        text = f.read()

    pairings = []
    for pid, base, duties in re.findall(pattern, text):
        pairings.append({
            "id": f"SOL_{pid}",
            "base": base,
            "duties": [d.strip() for d in duties.split(",") if d.strip()],
        })
    return pairings




def cheap_cost(duties):
    return 500 + 100 * len(duties)


# --------------------------------------------------
# Pairing generators
# --------------------------------------------------

def local_perturb(pairing):
    d = pairing["duties"]
    out = []

    if len(d) > 2:
        out.append(d[1:])
        out.append(d[:-1])

    for i in range(1, len(d) - 1):
        nd = d[:i] + d[i+1:]
        if len(nd) >= 2:
            out.append(nd)

    mid = len(d) // 2
    if mid >= 2 and len(d) - mid >= 2:
        out.append(d[:mid])
        out.append(d[mid:])

    return out


def forced_duty_generators(solution):
    freq = Counter()
    for p in solution:
        freq.update(p["duties"])

    forced = [d for d, c in freq.items() if c == 1]
    by_duty = defaultdict(list)

    for p in solution:
        for d in p["duties"]:
            if d in forced:
                by_duty[d].append(p)

    return forced, by_duty


def forced_alternative(duty, source_pairing):
    i = source_pairing["duties"].index(duty)
    d = source_pairing["duties"]

    if i > 0:
        return d[i-1:i+1]
    if i < len(d) - 1:
        return d[i:i+2]

    return None


def generate_sample(
    solution,
    target_size,
    time_limit,
    mode,
    seed=0
):
    random.seed(seed)
    start = time.time()

    pool = []
    seen = set()

    # always include solution pairings
    for p in solution:
        key = tuple(p["duties"])
        seen.add(key)
        pool.append({
            "base": p["base"],
            "duties": p["duties"],
            "cost": cheap_cost(p["duties"])
        })

    forced, forced_map = forced_duty_generators(solution)

    while len(pool) < target_size and time.time() - start < time_limit:
        if mode == "local":
            src = random.choice(solution)
            candidates = local_perturb(src)

        elif mode == "forced":
            d = random.choice(forced)
            src = random.choice(forced_map[d])
            alt = forced_alternative(d, src)
            candidates = [alt] if alt else []

        elif mode == "mixed":
            r = random.random()
            if r < 0.6:
                src = random.choice(solution)
                candidates = local_perturb(src)
            elif r < 0.9:
                d = random.choice(forced)
                src = random.choice(forced_map[d])
                alt = forced_alternative(d, src)
                candidates = [alt] if alt else []
            else:
                # mild random recombination
                p1, p2 = random.sample(solution, 2)
                cut = min(len(p1["duties"]), len(p2["duties"])) // 2
                candidates = [p1["duties"][:cut] + p2["duties"][cut:]]

        else:
            raise ValueError(f"Unknown mode {mode}")

        for d in candidates:
            if not d or len(d) < 2:
                continue

            key = tuple(d)
            if key in seen:
                continue

            seen.add(key)
            pool.append({
                "base": random.choice(solution)["base"],
                "duties": d,
                "cost": cheap_cost(d)
            })

            if len(pool) >= target_size:
                break

    return pool, time.time() - start


# --------------------------------------------------
# Main driver
# --------------------------------------------------

if __name__ == "__main__":
    solution = parse_solution("/content/sample_data/initialSolution.txt")

    configs = [
        ("0K",        0,       10),
        ("50K",   50_000,      30),
        ("500K", 500_000,     180),
    ]

    modes = ["local", "forced", "mixed"]

    out_root = Path("samples")
    out_root.mkdir(exist_ok=True)

    for name, target, time_limit in configs:
        dirpath = out_root / f"size_{name}"
        dirpath.mkdir(exist_ok=True)

        print(f"\n=== Generating {name} samples ===")

        for mode in modes:
            pool, elapsed = generate_sample(
                solution,
                target_size=max(target, len(solution)),
                time_limit=time_limit,
                mode=mode,
                seed=42
            )

            outfile = dirpath / f"{mode}.json"
            with open(outfile, "w") as f:
                json.dump(pool, f, indent=2)

            print(f"{mode:>6}: {len(pool):>7} pairings "
                  f"in {elapsed:5.1f}s")
