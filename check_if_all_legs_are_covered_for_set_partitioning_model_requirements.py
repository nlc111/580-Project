# -*- coding: utf-8 -*-
"""Check-if_all_legs_are_covered_for_set_partitioning_model_requirements.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sdGRcEXmV0mrneC1ueAxXeZ9KVEK2xv0
"""



# Read legs.csv manually
all_legs = set()
with open('/content/sample_data/legs.csv', 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Skip the header and split by tab
for line in lines[1:]:
    parts = line.strip().split('\t')
    if len(parts) >= 2:
        leg_id = parts[1]
        all_legs.add(leg_id)

print(f"Total legs in legs.csv: {len(all_legs)}")

# Now read initialsolution.in
import re

with open('/content/sample_data/initialSolution.in', 'r', encoding='utf-8') as f:
    content = f.read()

# Find all LEG_* entries
legs_in_solution = set(re.findall(r'LEG_\d+_\d+', content))

print(f"Total legs in initialsolution.in: {len(legs_in_solution)}")

# Check missing legs
missing_legs = all_legs - legs_in_solution
print(f"Number of legs missing from initialsolution.in: {len(missing_legs)}")
if missing_legs:
    print("Missing legs:")
    for leg in sorted(missing_legs):
        print(leg)

import re

# Read solution_0.txt
with open('/content/sample_data/solution_0.txt', 'r', encoding='utf-8') as f:
    solution_content = f.read()

# Find all LEG_* entries
legs_in_solution_0 = set(re.findall(r'LEG_\d+_\d+', solution_content))

print(f"Total legs covered in solution_0.txt: {len(legs_in_solution_0)}")

# Check which legs from initialsolution.in are missing in solution_0
legs_missing_from_solution_0 = legs_in_solution - legs_in_solution_0
print(f"Number of legs in initialsolution.in missing from solution_0.txt: {len(legs_missing_from_solution_0)}")
if legs_missing_from_solution_0:
    print("Missing legs:")
    for leg in sorted(legs_missing_from_solution_0):
        print(leg)

# Optional: legs that appear in multiple pairings in solution_0
from collections import Counter
all_solution_legs = re.findall(r'LEG_\d+_\d+', solution_content)
duplicates = [leg for leg, count in Counter(all_solution_legs).items() if count > 1]
print(f"Legs appearing multiple times in solution_0.txt: {duplicates}")

# checking to see if multiple legs appear in initialSolution.in

import re
from collections import defaultdict

# Path to your initialSolution.in file
filename = "/content/sample_data/initialSolution.in"

# Dictionary to track which pairings each leg appears in
leg_to_pairings = defaultdict(list)

# Read the file
with open(filename, "r") as f:
    data = f.read()

# Find all pairings
pairings = re.findall(r'Pairing \d+ : Base [^:]+ : (.*?);', data, re.DOTALL)

for idx, pairing in enumerate(pairings, start=1):
    # Split legs by comma and remove whitespace
    legs = [leg.strip() for leg in pairing.split(',')]
    for leg in legs:
        leg_to_pairings[leg].append(idx)

# Find legs that appear in more than one pairing
multiple_legs = {leg: p for leg, p in leg_to_pairings.items() if len(p) > 1}

print(f"Total legs in initialSolution.in: {len(leg_to_pairings)}")
print(f"Legs appearing multiple times: {len(multiple_legs)}")
if multiple_legs:
    for leg, pair_list in multiple_legs.items():
        print(f"{leg} appears in pairings: {pair_list}")

import pulp

# --- Define pairings ---
# Each key is a pairing ID, each value is the list of legs it contains
pairings = {
    52: ["TDH_LEG_09_26", "TDH_LEG_09_16", "LEG_07_0", "LEG_07_1"],
    73: ["TDH_LEG_09_26", "TDH_LEG_09_16", "LEG_08_23"],
    1: ["LEG_29_1", "LEG_30_11", "LEG_30_0"],
    2: ["LEG_29_3", "LEG_30_19", "LEG_30_21"],
}

# Optional: define a simple cost for each pairing
costs = {k: len(v) for k, v in pairings.items()}  # e.g., minimize total number of legs per pairing

# --- Create LP problem ---
prob = pulp.LpProblem("SetPartitioningExample", pulp.LpMinimize)

# --- Decision variables ---
x = {p: pulp.LpVariable(f"x_{p}", cat="Binary") for p in pairings}

# --- Objective: minimize total cost ---
prob += pulp.lpSum(costs[p] * x[p] for p in pairings)

# --- Constraints: each leg can appear in exactly one selected pairing ---
# First, find all unique legs
all_legs = set(leg for pair in pairings.values() for leg in pair)

for leg in all_legs:
    # Get all pairings containing this leg
    pairings_with_leg = [p for p, legs in pairings.items() if leg in legs]
    prob += pulp.lpSum(x[p] for p in pairings_with_leg) == 1, f"leg_{leg}_constraint"

# --- Solve ---
prob.solve()

# --- Show solution ---
print(f"Status: {pulp.LpStatus[prob.status]}")
for p in pairings:
    if pulp.value(x[p]) == 1:
        print(f"Selected pairing {p}: {pairings[p]}")

"""Issues with the above snippet logic:"""

import pulp

# --- Legs and Pairings ---
legs = [
    'TDH_LEG_09_26', 'TDH_LEG_09_16',
    'LEG_07_0', 'LEG_07_1', 'LEG_08_23',
    'LEG_29_1', 'LEG_30_11', 'LEG_30_0', 'LEG_29_3', 'LEG_30_19', 'LEG_30_21'
]

pairings = {
    52: ['TDH_LEG_09_26', 'TDH_LEG_09_16', 'LEG_07_0', 'LEG_07_1'],
    73: ['TDH_LEG_09_26', 'TDH_LEG_09_16', 'LEG_08_23'],
    1:  ['LEG_29_1', 'LEG_30_11', 'LEG_30_0'],
    2:  ['LEG_29_3', 'LEG_30_19', 'LEG_30_21']
}

# --- Create model ---
prob = pulp.LpProblem("SetPartitioningExample", pulp.LpMinimize)

# Decision variables
x = {p: pulp.LpVariable(f"x_{p}", cat="Binary") for p in pairings}

# Dummy objective (minimize total number of pairings selected)
prob += pulp.lpSum(x.values())

# Constraints: each leg appears exactly once
for leg in legs:
    prob += pulp.lpSum(x[p] for p in pairings if leg in pairings[p]) == 1, f"cover_{leg}"

# Solve
prob.solve()

# --- Output results ---
print("Status:", pulp.LpStatus[prob.status])
for p in pairings:
    if x[p].value() == 1:
        print(f"Selected pairing {p}: {pairings[p]}")

"""RESULT: TURNS OUT THAT THE ISSUE IS THAT TDH LEGS SHOULD NOT BE TREATED OR PENALIZED IN THE SET PARTITIONING PROBLEM. JUST NEED TO INCLUDE LOGIC SO THAT I"""