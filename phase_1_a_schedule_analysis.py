# -*- coding: utf-8 -*-
"""Phase 1 A schedule_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XsiGV5gkAcbfdQjTi9UgA4FvlMFdXVBE
"""

using CSV
using DataFrames
using Dates
using Statistics

"""
Phase 1: Deterministic Calculation of Flight Times, Duties, and Credits
Reads day_*.csv files and solution_0 to calculate schedule metrics
"""

# Configuration
const DATA_DIR = "/content/sample_data/DATA_DIR"  # Change this to your data directory
const BRIEFING_HOURS = 1.0  # Hours per duty for briefing/debriefing

"""
Parse time string in format HH:MM to hours as Float64
"""
function parse_time_to_hours(time_str::String)
    h, m = split(time_str, ':')
    return parse(Int, h) + parse(Int, m) / 60.0
end

"""
Calculate flight duration in hours between departure and arrival
Handles flights that cross midnight
"""
function calculate_flight_time(date_dep::String, hour_dep::String,
                               date_arr::String, hour_arr::String)
    dep_date = Date(date_dep, "yyyy-mm-dd")
    arr_date = Date(date_arr, "yyyy-mm-dd")

    dep_time = parse_time_to_hours(hour_dep)
    arr_time = parse_time_to_hours(hour_arr)

    # Calculate duration considering day change
    day_diff = Dates.value(arr_date - dep_date)
    duration = (day_diff * 24.0) + arr_time - dep_time

    return duration
end

"""
Load all day_*.csv files into a dictionary
Returns: Dict{String, Float64} mapping leg_nb to flight_time_hours
"""
function load_flight_data(data_dir::String, num_days::Int=31)
    println("Loading flight data from day files...")
    flight_dict = Dict{String, Float64}()

    for day in 1:num_days
        filename = joinpath(data_dir, "day_$day.csv")

        if !isfile(filename)
            println("Warning: $filename not found, skipping...")
            continue
        end

        # Read CSV with specific column types
        df = CSV.read(filename, DataFrame,
             types=Dict(:date_dep=>String, :date_arr=>String,
                       :hour_dep=>String, :hour_arr=>String),
             stripwhitespace=true)

        # Calculate flight time for each leg
        for row in eachrow(df)
            leg_nb = strip(String(row[Symbol("#leg_nb")]))

            flight_time = calculate_flight_time(
                row[:date_dep], row[:hour_dep],
                row[:date_arr], row[:hour_arr]
            )

            flight_dict[leg_nb] = flight_time
        end

        println("  Loaded day_$day.csv: $(nrow(df)) legs")
    end

    println("Total legs loaded: $(length(flight_dict))\n")
    return flight_dict
end

"""
Extract day number from leg name (e.g., "LEG_07_23" -> 7)
"""
function extract_day_from_leg(leg_name::String)
    # Handle both LEG and PAL_LEG prefixes
    leg_clean = startswith(leg_name, "PAL_") ? leg_name[5:end] : leg_name

    parts = split(leg_clean, '_')
    if length(parts) >= 2
        return parse(Int, parts[2])
    end
    return -1
end

"""
Determine if a task is a flight leg (not vacation, deadhead, etc.)
"""
function is_flight_leg(task::String)
    task = strip(task)

    # Exclude non-flight tasks
    if task == "VACATION" ||
       startswith(task, "POST_") ||
       startswith(task, "TDH_") ||
       startswith(task, "AST_")
        return false
    end

    # Must be LEG or PAL_LEG
    return startswith(task, "LEG_") || startswith(task, "PAL_LEG_")
end

"""
Parse a single schedule line from solution_0
Returns: (schedule_num, employee, base, tasks)
"""
function parse_schedule_line(line::String)
    # Format: schedule 1 EMP007 (BASE3) : TASK--->TASK--->...;

    # Extract schedule number
    m = match(r"schedule (\d+)", line)
    schedule_num = m !== nothing ? parse(Int, m.captures[1]) : -1

    # Extract employee
    m = match(r"(EMP\d+)", line)
    employee = m !== nothing ? m.captures[1] : ""

    # Extract base (inside parentheses)
    m = match(r"\(([A-Z0-9]+)\)", line)
    base = m !== nothing ? m.captures[1] : ""

    # Extract tasks (everything after : and before ;)
    m = match(r":\s*(.+);", line)
    if m !== nothing
        tasks_str = m.captures[1]
        tasks = split(tasks_str, "--->")
        tasks = [strip(t) for t in tasks]
    else
        tasks = String[]
    end

    return (schedule_num, employee, base, String.(tasks))
end

"""
Calculate metrics for a single schedule
Returns: Dict with flight_time, duties, briefing_credit, net_credits
"""
function analyze_schedule(tasks::Vector{String}, flight_dict::Dict{String, Float64})
    total_flight_time = 0.0
    flying_days = Set{Int}()
    leg_count = 0
    missing_legs = String[]

    for task in tasks
        if is_flight_leg(task)
            # Remove PAL_ prefix if present
            leg_name = startswith(task, "PAL_") ? task[5:end] : task

            # Get flight time
            if haskey(flight_dict, leg_name)
                total_flight_time += flight_dict[leg_name]
                leg_count += 1

                # Track flying days for duty calculation
                day = extract_day_from_leg(task)
                if day > 0
                    push!(flying_days, day)
                end
            else
                push!(missing_legs, leg_name)
            end
        end
    end

    num_duties = length(flying_days)
    briefing_credit = num_duties * BRIEFING_HOURS

    # Net credits = flight time - briefing/debriefing
    # (Note: actual credited hours may include additional credits not captured here)
    net_credits = total_flight_time - briefing_credit

    return Dict(
        "flight_time" => total_flight_time,
        "num_duties" => num_duties,
        "briefing_credit" => briefing_credit,
        "net_credits" => net_credits,
        "leg_count" => leg_count,
        "missing_legs" => missing_legs
    )
end

"""
Parse solution_0 file and calculate metrics for all schedules
"""
function process_solution(solution_file::String, flight_dict::Dict{String, Float64})
    println("Processing solution file: $solution_file")

    if !isfile(solution_file)
        error("Solution file not found: $solution_file")
    end

    results = DataFrame(
        schedule_num = Int[],
        employee = String[],
        base = String[],
        flight_time_hours = Float64[],
        num_duties = Int[],
        briefing_hours = Float64[],
        calculated_credits = Float64[],
        num_legs = Int[]
    )

    content = read(solution_file, String)
    lines = split(content, '\n')

    for line in lines
        if occursin("schedule", line) && occursin(":", line)
            schedule_num, employee, base, tasks = parse_schedule_line(string(line))

            if schedule_num > 0
                metrics = analyze_schedule(tasks, flight_dict)

                push!(results, (
                    schedule_num,
                    employee,
                    base,
                    metrics["flight_time"],
                    metrics["num_duties"],
                    metrics["briefing_credit"],
                    metrics["net_credits"],
                    metrics["leg_count"]
                ))

                if !isempty(metrics["missing_legs"])
                    println("  Schedule $schedule_num: $(length(metrics["missing_legs"])) missing legs")
                end
            end
        end
    end

    println("Processed $(nrow(results)) schedules\n")
    return results
end

"""
Load actual credited hours from creditedHours file for comparison
"""
function load_actual_credits(credits_file::String)
    println("Loading actual credited hours from: $credits_file")

    if !isfile(credits_file)
        println("Warning: creditedHours file not found")
        return DataFrame()
    end

    actual_credits = DataFrame(
        schedule_num = Int[],
        actual_credits = Float64[],
        actual_cost = Float64[],
        vacations = Int[]
    )

    content = read(credits_file, String)
    lines = split(content, '\n')

    current_schedule = -1
    for line in lines
        # Extract schedule number
        m = match(r"Schedule (\d+)", line)
        if m !== nothing
            current_schedule = parse(Int, m.captures[1])
        end

        # Extract credited hours
        m = match(r"credited hours\s*:\s*([\d.]+)", line)
        if m !== nothing && current_schedule > 0
            credits = parse(Float64, m.captures[1])
            push!(actual_credits, (current_schedule, credits, 0.0, 0))
        end

        # Extract cost
        m = match(r"schedule cost\s*:\s*([\d.]+)", line)
        if m !== nothing && !isempty(actual_credits)
            actual_credits[end, :actual_cost] = parse(Float64, m.captures[1])
        end

        # Extract vacations
        m = match(r"number of vacations:\s*(\d+)", line)
        if m !== nothing && !isempty(actual_credits)
            actual_credits[end, :vacations] = parse(Int, m.captures[1])
        end
    end

    println("Loaded $(nrow(actual_credits)) schedule credits\n")
    return actual_credits
end

"""
Main analysis function
"""
function main()
    println("="^60)
    println("CREW SCHEDULE ANALYSIS - PHASE 1")
    println("Deterministic Calculation of Credits and Flight Times")
    println("="^60)
    println()

    # Load flight data
    flight_dict = load_flight_data(DATA_DIR, 31)

    # Process solution
    solution_file = joinpath(DATA_DIR, "solution_0.txt")
    calculated_results = process_solution(solution_file, flight_dict)

    # Load actual credits
    credits_file = joinpath(DATA_DIR, "creditedHours.txt")
    actual_credits = load_actual_credits(credits_file)

    # Merge calculated and actual
    if !isempty(actual_credits)
        results = leftjoin(calculated_results, actual_credits, on=:schedule_num)

        # Calculate difference
        results.credit_difference = results.actual_credits .- results.calculated_credits

        println("="^60)
        println("SUMMARY STATISTICS")
        println("="^60)
        println("Total schedules: $(nrow(results))")
        println("\nFlight Time:")
        println("  Mean: $(round(mean(results.flight_time_hours), digits=2)) hours")
        println("  Min:  $(round(minimum(results.flight_time_hours), digits=2)) hours")
        println("  Max:  $(round(maximum(results.flight_time_hours), digits=2)) hours")

        println("\nDuties:")
        println("  Mean: $(round(mean(results.num_duties), digits=1))")
        println("  Min:  $(minimum(results.num_duties))")
        println("  Max:  $(maximum(results.num_duties))")

        if any(!ismissing, results.actual_credits)
            println("\nCredits Comparison:")
            println("  Mean actual:     $(round(mean(skipmissing(results.actual_credits)), digits=2)) hours")
            println("  Mean calculated: $(round(mean(results.calculated_credits), digits=2)) hours")
            println("  Mean difference: $(round(mean(skipmissing(results.credit_difference)), digits=2)) hours")
        end

        println("\nBy Base:")
        for base in unique(results.base)
            base_data = filter(row -> row.base == base, results)
            println("  $base: $(nrow(base_data)) schedules, ",
                   "$(round(sum(base_data.calculated_credits), digits=1)) total credits")
        end
    else
        results = calculated_results
    end

    # Save results
    output_file = "schedule_analysis_phase1.csv"
    CSV.write(output_file, results)
    println("\n" * "="^60)
    println("Results saved to: $output_file")
    println("="^60)

    return results
end

# Run the analysis
results = main()